DECLARE SUB PORTBTEST ()
DECLARE SUB SCREEN.SETUP ()
DECLARE SUB TEMPDUMP (MODE!, DELAY.SEC!, MAX.DUMP!)
DECLARE SUB BRDGZERO ()
DECLARE SUB INTTEST (D!)
DECLARE SUB GAIN (GAINMD!, GAINTD!)
DECLARE SUB DSPTEST ()
DECLARE SUB LEDTEST ()
DECLARE SUB COMMAND (CMND!, CMNDECHO!)
DECLARE SUB INTERFACEBUFF (RESULT!)
DECLARE SUB INTFCREAD (A!)
DECLARE SUB AVGAD (ADAVG!(), COUNT!)
DECLARE SUB LINEARITY (CHANNEL%)
DECLARE SUB LATCHOUT (BITVAL%, SET.CLR%)
DECLARE SUB DAC0OUT (V!)
DECLARE SUB DELAY (A!)
DECLARE SUB ADMUX (GROUP%)
DECLARE SUB DAC1OUT (V!)
DECLARE SUB ADMEASURE (ADBUFF!())

' IO BASE ADDRES USING 82C55 CONTROL CHIP

CONST IOBASE% = &H300
CONST IOPORTA% = IOBASE
CONST IOPORTB% = IOBASE + 1
CONST IOPORTC% = IOBASE + 2
CONST CONTROL% = IOBASE + 3

' WRITE ADDRESS TO THE 82C55 PORT B WHICH ARE DECODED ON THE INTERFACE
' BOARD. THE ADDRESS IS THE ADDRESS ON THE INTERFACE BOARD WHICH ARE
' OUTPUT ON PORTB. AFTER WRITING THE ADDRESS THE VALUE IS THEN WRITTEN
' TO PORT A WHICH IS THEN STROBED INTO THE APPROPRIATE ADDR.

CONST INTRFCCOMMAND% = &H80
CONST INTRFCLATCH% = &H90
CONST DAC0LOADD% = &HA0
CONST DAC0HIADD% = &HB0
CONST DAC1LOADD% = &HC0
CONST DAC1HIADD% = &HD0
CONST CNTRWRADDR% = &HE0

' READ ADDRESSES ARE OUTPUT ON PORT B. THE INTERFACE STROBES THE DATA
' INTO PORT A FOR INPUT. IT IS ESSENTIAL TO KNOW THAT SOME READ DO NOT
' RETURN A VALUE BUT SIMPLE STORE THE ADDR.

CONST MUXCHANNEL% = &H10
CONST MUXGROUP1% = MUXCHANNEL% + 0
CONST MUXGROUP2% = MUXCHANNEL% + 1
CONST MUXGROUP3% = MUXCHANNEL% + 2
CONST MUXGROUP4% = MUXCHANNEL% + 3
CONST IOREAD% = &H20
CONST ADTRIG% = &H30
CONST ADNEXT% = &H40
CONST CNTRRDADDR% = &H60
CONST IOMODES% = &HC4
CONST ABORT% = &HFF
CONST INPUTMODE% = &H9B

INTRFCCNTRL% = 0
INTRFCCMND% = 0
INTRFCDATA% = 0
CHANNEL% = 0

' THESE ARE THE BIT VALUES IN THE INTRFCNTRL BYTE VARIABLE WHICH ARE
' USED TO CONTROL THE INTERFACE

CONST DATAREQ% = 1, BATSEL% = 2, ZEROCAL% = 4
CONST READY% = 8, MARK% = 16, RUNNING% = 32, INTEN% = 64, CPURESET% = 128
CONST SET.BIT% = 1, CLEAR.BIT% = 0


' COMMAND DEFINITION CONSTANTS. THESE ARE THE VALUES SENT TO THE
' STRETCHER INTERFACE COMMAND REGISTERS.

CONST FIRST.TEMP% = 1, NEXT.TEMP% = 2, STOP.TRANSFER% = 3, START.CAPTURE% = 4
CONST STOP.CAPTURE% = 5, SEND.MSB.COUNT% = 6, SEND.LSB.COUNT% = 7
CONST STATUS.REQ% = 8, CAL.REQ% = 9, SCI.TAP% = 10, ALT.STATUS.REQ% = &H1F

DIM ADBUFF(5)
DIM ADAVG(5)
DIM SUM(5)

OUT CONTROL%, IOMODES%
OUT IOBORTB%, ABORT%

' This is the main test procedure part. You will require a DVM, Oscilliscope
'
TEST.PROC:
CALL SCREEN.SETUP
DO
  QUIT.FLAGE = 0
  LOCATE 12, 20: PRINT "       "
  LOCATE 12, 1: INPUT "YOUR REQUEST PLEASE"; REQUEST
' Clear variable text screen below
  FOR I = 13 TO 23
    LOCATE I, 1
    PRINT "                                                                  "
  NEXT I
  SELECT CASE REQUEST
    CASE 1
      ' +10V Ref. Adj routine
      LOCATE 16, 1: PRINT " CONNECT DVM + TO TP27 AND - TO ANGND.  "
      LOCATE 17, 1: PRINT " ADJUST R106 +10V REF ADJ. POT FOR +10.00 VOLTS ON THE DVM"
      LOCATE 18, 1: PRINT " I WILL MONITOR WITH MY A/D CONVERTER"
      LOCATE 19, 1: PRINT " HIT ANY KEY TO ABORT"
      CALL ADMUX((2))
      CALL DELAY((1000))
      DO
        LOCATE 5, 1
        CALL AVGAD(ADAVG(), (100))
        A = ADAVG(4) / 204.8
        LOCATE 23, 1: PRINT "A/D READ "; A
      LOOP WHILE INKEY$ = ""
      A = ABS(A - 10!)
      IF A > .01 THEN
        LOCATE 21, 1: PRINT "SOMETHING WRONG IN A/D MUX CHAIN, FIND AND FIX"
      ELSE
        LOCATE 21, 1: PRINT "A/D READ IS EXCEPTABLE"
      END IF
    CASE 2
      ' Thermocouple calibrate full scale adjust.
      LOCATE 16, 1: PRINT "CONNECT DVM TO TP29 AND ANGND"
      LOCATE 17, 1: PRINT "ADJUST R107 FOR 1.7 FOR 1.7V"
      LOCATE 18, 1: PRINT "CYCLE POWER ON UNIT AND CHECK IF IT POWERS UP AND READS"
      LOCATE 19, 1: PRINT "HIT ANY KEY TO CONTINUE"
      DO: LOOP WHILE INKEY$ = ""
    CASE 3
      ' Front panel display segment test.
      LOCATE 16, 1: PRINT "CYCLE POWER ON UNIT AND CHECK IF IT POWERS UP AND READS"
      LOCATE 17, 1: PRINT "CHECK ALL LED SEGMENTS AND FIX IF OUT"
      LOCATE 18, 1: PRINT "HIT ANY KEY TO ABORT"
      CALL DSPTEST
      DO: LOOP WHILE INKEY$ = ""
      CALL LATCHOUT(CPURESET%, CLEAR.BIT%)
    CASE 4
      ' Front panel ready,mark,run led test.
      LOCATE 16, 1
      PRINT "PLEASE OBSERVE FRONT PANEL READY,MARK & RUNNING LED'S"
      LOCATE 17, 1: PRINT "HIT ANY KEY TO CONTINUE"
      DO: LOOP WHILE INKEY$ = ""
      CALL LEDTEST
    CASE 5
      'Temperature transfer command test
      LOCATE 16, 1: PRINT "TEMPERATURE FROM INTERFACE"
      LOCATE 17, 1: PRINT "HIT ANY KEY TO ABORT"
      DO
        CALL INTTEST((10000))      ' WAIT FOR 1 SECOND APPROX
        CALL COMMAND((1), HITEMP): CALL COMMAND((2), LOTEMP)
        LOCATE 18, 1: PRINT USING "###.##"; (HITEMP * 256 + LOTEMP) / 10
        FOR I = 1 TO 3
          CALL COMMAND((2), HITEMP): CALL COMMAND((2), LOTEMP)
          LOCATE 18, I * 10: PRINT USING "###.##"; (HITEMP * 256 + LOTEMP) / 10
        NEXT I
      LOOP WHILE INKEY$ = ""
    CASE 6
    ' Battery test.
      LOCATE 16, 1: PRINT "CONNECT A JUMPER FROM D/A-0 TP3 TO BATTERY JP30"
      LOCATE 17, 1: PRINT "HIT ANY KEY TO CONTINUE"
      CALL ADMUX((2))                     ' SET TO GROUP 1
      CALL LATCHOUT(BATSEL%, SET.BIT%)
      CALL DELAY((10000))
      CALL DAC0OUT((4000))               ' SET D/A TO +5V
      DO
        CALL AVGAD(ADAVG(), (100))
        A = ADAVG(1) / 204.8
        LOCATE 18, 1: PRINT "D/A=4.76V, A/D READS "; A
      LOOP WHILE INKEY$ = ""
      CALL LATCHOUT(BATSEL%, CLEAR.BIT%)
    CASE 7
       LOCATE 16, 1: PRINT " TEST THE RS232 USING PROCOMM AND COM2"
       LOCATE 17, 1: PRINT " OF THE HOST CPU"
    CASE 8
      LOCATE 16, 1: PRINT "CONNECT FLUKE DVM TO TP33 A/D CLOCK AND VERIFY"
      LOCATE 17, 1: PRINT "FREQ SETTING TO BE 65 KHZ"
      LOCATE 18, 1: PRINT "HIT ANY KEY TO ABORT "
      DO: LOOP WHILE INKEY$ = ""
    CASE 9
      ' Temperature A/D converter test    
      LOCATE 16, 1: PRINT "TEMPERATURE; A / D; TEST; "
      LOCATE 17, 1: PRINT "HIT ANY KEY TO ABORT"
      CALL ADMUX((1))
      DO
        CALL AVGAD(ADAVG(), (100))
        FOR I = 1 TO 4
          LOCATE 19, I * 10: PRINT USING "###.###"; ADAVG(I) / 204.8
        NEXT I
      LOOP WHILE INKEY$ = ""
    CASE 10
      CALL LATCHOUT(ZEROCAL%, SET.BIT%)
      CALL DAC0OUT((2048))
      CALL DAC1OUT((2048))
      CALL ADMUX((0))
      LOCATE 16, 1: PRINT "PLEASE ADJ. X&Y-STRAIN DC ZERO R1 & R2, FOR ZERO"
      LOCATE 18, 1: PRINT " MUST BE LESS THAN .005"
      LOCATE 20, 1: PRINT "X-STRAIN ZERO:            Y-STRAIN ZERO:"
      DO
        CALL AVGAD(ADAVG(), (100))
        X.ZERO = ADAVG(2) / 204.8
        Y.ZERO = ADAVG(4) / 204.8
        LOCATE 20, 17: PRINT USING "###.####"; X.ZERO
        LOCATE 20, 45: PRINT USING "###.####"; Y.ZERO
      LOOP WHILE INKEY$ = ""
    CASE 11
      LOCATE 16, 1: PRINT "PLEASE ADJ. X&Y-STRAIN DC GAIN R42 & R82, FOR 270"
      LOCATE 20, 1: PRINT "X-STRAIN GAIN:            Y-STRAIN GAIN:"
      DO
        CALL GAIN(MDGAIN, TDGAIN)
        LOCATE 20, 17: PRINT USING "####.####"; MDGAIN
        LOCATE 20, 45: PRINT USING "####.####"; TDGAIN
      LOOP WHILE INKEY$ = ""
    CASE 12
      LOCATE 16, 1: PRINT "CALIBRATE THE 4 CHANNEL THERMOCOUPLE WITH"
      LOCATE 17, 1: PRINT "OMEGA  CALIBRATOR TO 0.1 DEG C."
      LOCATE 18, 1: PRINT "USE FRONT PANEL DISPLAYS FOR CALIBRATION"
    CASE 13
     LOCATE 16, 1: PRINT "CONNECT SCOPE TO TP3 AND ANGND. OBSERVE THE"
     LOCATE 17, 1: PRINT " TRIANGLE WAVEFORM"
     LOCATE 18, 1: PRINT "HIT ANY KEY TO ABORT"
     DO
       FOR V = 0 TO 4095
         CALL DAC0OUT(V)
       NEXT V
     LOOP WHILE INKEY$ = ""
    CASE 14
     LOCATE 16, 1: PRINT "CONNECT SCOPE TO TP8 AND ANGND. OBSERVE THE"
     LOCATE 17, 1: PRINT " TRIANGLE WAVEFORM"
     LOCATE 18, 1: PRINT "HIT ANY KEY TO ABORT"
     DO
       FOR V = 0 TO 4095
         CALL DAC1OUT(V)
       NEXT V
     LOOP WHILE INKEY$ = ""
    CASE 15
      ' A/D D/A LIN TEST  
      LOCATE 16, 1: PRINT " D/A IS SWEPT FROM -5V TO +5V AND A/D CONVERTED"
      LOCATE 17, 1: PRINT " A STRAIN LINE EQUATION IS CALCULATED FOR THE TEST"
      LOCATE 18, 1: PRINT " WORKING "
      CALL ADMUX((3)): CALL DELAY((10000)): CALL LINEARITY((0))
      LOCATE 15, 1: PRINT "ALL DONE"
    CASE 16
      LOCATE 16, 1: PRINT " ADJUST X & Y V-EXC R8 & R62 FOR +5.000V"
      LOCATE 17, 1: PRINT " USE DVM AT TP7 & TP2 FOR ACCURACY"
      LOCATE 18, 1: PRINT " VERIFY A/D TO BE WITHIN 0.1%"
      LOCATE 19, 1: PRINT "HIT ANY KEY TO ABORT"
      CALL ADMUX((2))
      LOCATE 20, 1: PRINT "X-EXE VOLT:            Y-EXC VOLT:"
      DO
        CALL AVGAD(ADAVG(), (100))
        X.EXC = ADAVG(2) / 204.8
        Y.EXC = ADAVG(3) / 204.8
        LOCATE 20, 17: PRINT USING "###.####"; X.EXC
        LOCATE 20, 45: PRINT USING "###.####"; Y.EXC
      LOOP WHILE INKEY$ = ""
    CASE 17
      LOCATE 16, 1: PRINT " A/D ZERO TEST. SHOULD BE LESS THAN .005"
      LOCATE 17, 1: PRINT " CAN ONLY TEST CHANNEL 3 & 4"
      LOCATE 18, 1: PRINT "HIT ANY KEY TO ABORT"
      CALL ADMUX((3))
      LOCATE 20, 1: PRINT "A/D ZERO CHN 3:            A/D ZERO CHN 4:"
      DO
        CALL AVGAD(ADAVG(), (100))
        X.ZERO = ADAVG(3) / 204.8
        Y.ZERO = ADAVG(4) / 204.8
        LOCATE 20, 17: PRINT USING "###.####"; X.ZERO
        LOCATE 20, 45: PRINT USING "###.####"; Y.ZERO
      LOOP WHILE INKEY$ = ""

    CASE 18
      LOCATE 16, 1: PRINT " A/D FULL SCALE TEST. SHOULD BE LESS THAN .005"
      LOCATE 17, 1: PRINT " CAN ONLY TEST CHANNEL 3 & 4"
      LOCATE 18, 1: PRINT "HIT ANY KEY TO ABORT"
      CALL ADMUX((2))
      LOCATE 20, 1: PRINT "A/D FULL SCALE CHN 3:"
      DO
        CALL AVGAD(ADAVG(), (100))
        X.ZERO = ADAVG(4) / 204.8
        LOCATE 20, 25: PRINT USING "###.####"; X.ZERO
      LOOP WHILE INKEY$ = ""
 
    CASE 19
        ADMUX ((0)): CALL LATCHOUT(ZEROCAL%, CLEAR.BIT%)
        DO
          CALL AVGAD(ADAVG(), (100))
          LOCATE 16, 1: PRINT "HIT ANY KEY TO ABORT"
          LOCATE 18, 4: PRINT "X-POS"
          LOCATE 18, 12: PRINT "X-STRAIN"
          LOCATE 18, 20: PRINT "Y-POS"
          LOCATE 18, 28: PRINT "Y-STRAIN"
          LOCATE 20, 1
          FOR I = 1 TO 4
            PRINT USING "###.###"; ADAVG(I) / 204.8;
          NEXT I
        LOOP WHILE INKEY$ = ""
    CASE 20
    '      LOCATE 16, 1: PRINT "HIT ANY KEY TO ABORT"
          CALL BRDGZERO
    CASE 21
          LOCATE 16, 1: PRINT "HIT ANY KEY TO ABORT"
          LOCATE 17, 1: INPUT "RUN/CMD: 0,1; #SEC; # SET DUMP"; MODE, DELAY.SEC, MAX.DUMP
          LOCATE 18, 1: CLS
          DO
            CALL TEMPDUMP(MODE, DELAY.SEC, MAX.DUMP)
          LOOP WHILE INKEY$ = ""
          CALL SCREEN.SETUP
    CASE 22
      QUIT.FLAG = 1
    CASE 23
      PORTBTEST
    CASE ELSE
      PRINT "INCORRECT REQUEST"
  END SELECT
LOOP WHILE QUIT.FLAG = 0
OUT CONTROL%, INPUTMODE%
STOP


END

SUB ADMEASURE (ADBUFF()) STATIC
  OUT IOPORTB%, ADTRIG%
  WHILE (INP(IOPORTC%) AND &H20) = 0: WEND
  A = INP(IOPORTA%)
  WHILE (INP(IOPORTC%) AND &H20) = 0: WEND
  B = INP(IOPORTA%)
  C& = A * 256 + B
  IF C& > 32767 THEN C& = C& - 65536
  ADBUFF(1) = C&
  FOR ADCHNL = 2 TO 4
    OUT IOPORTB%, ADNEXT%
    WHILE (INP(IOPORTC%) AND &H20) = 0: WEND
    A = INP(IOPORTA%)
    WHILE (INP(IOPORTC%) AND &H20) = 0: WEND
    B = INP(IOPORTA%)
    C& = A * 256 + B
    IF C& > 32767 THEN C& = C& - 65536
    ADBUFF(ADCHNL) = C&
  NEXT ADCHNL
END SUB

SUB ADMUX (GROUP%) STATIC
' GROUP 0= X-POS,X-STRAIN,Y-POS,Y-STRAIN
' GROUP 1= TM1,TM2,TM3,TM4
' GROUP 2= V-BAT,V-EXC-X,V-EXC-Y,V-REF
' GROUP 3= DAC0,DAC1,ANGND,ANGND
'
     OUT IOPORTB%, MUXCHANNEL% + GROUP%
END SUB

SUB AVGAD (ADAVG(), COUNT) STATIC
    SHARED ADBUFF()
    FOR I = 1 TO 4: ADAVG(I) = 0: NEXT I
      FOR I = 1 TO COUNT
        CALL ADMEASURE(ADBUFF())
        FOR J = 1 TO 4
          ADAVG(J) = (ADAVG(J) + ADBUFF(J))
        NEXT J
      NEXT I
    FOR I = 1 TO 4: ADAVG(I) = ADAVG(I) / COUNT: NEXT I
END SUB

SUB BRDGZERO STATIC
DIM ADAVG(5)
        ADMUX ((0)): CALL LATCHOUT(ZEROCAL%, CLEAR.BIT%)
        DA0TRY% = 2047: DA1TRY% = 2047
        CALL DAC0OUT((2047)): CALL DAC1OUT((2047)): CALL DELAY((1000))
        DO
          CALL AVGAD(ADAVG(), (100))
          IF ABS(ADAVG(2)) < 1 THEN
            EXIT DO
          ELSE
            DA0TRY% = DA0TRY% + ADAVG(2) * 3.7
            DAC0OUT (DA0TRY%): CALL DELAY((1000))
          END IF
        LOOP WHILE INKEY$ = ""
        LOCATE 20, 1: PRINT "A/D-X VOLTS="; ADAVG(2) / 204.8; "D/A-X COUNTS ="; DA0TRY%

        DO
          CALL AVGAD(ADAVG(), (100))
          IF ABS(ADAVG(4)) < 1 THEN
            EXIT DO
          ELSE
            DA1TRY% = DA1TRY% + ADAVG(4) * 3.7
            DAC1OUT (DA1TRY%): CALL DELAY((1000))
          END IF
        LOOP WHILE INKEY$ = ""
        LOCATE 21, 1: PRINT "A/D-Y VOLTS="; ADAVG(4) / 204.8; "D/A-Y COUNTS="; DA1TRY%

END SUB

SUB COMMAND (CMND, CMNDECHO) STATIC
     OUT IOPORTB%, INTRFCCOMMAND%       ' COMMAND BYTE ADDR
     OUT IOPORTA%, CMND                 ' COMMAND BYTE VALUE
     CALL LATCHOUT(DATAREQ%, SET.BIT%)  ' SET DATA REQ TO 8032
     WHILE (INP(IOPORTC%) AND &H20) = 0: WEND       ' WAIT FOR ACK FOR 8032
     CALL LATCHOUT(DATAREQ%, CLEAR.BIT%) ' CLEAR DATA REQ
     BA = INP(IOPORTA%)                  ' DUMMY READ TO EMPTY PORTA
     OUT IOPORTB%, IOREAD%              ' OUTPUT INTERFACE BUFF ADDR
     WHILE (INP(IOPORTC%) AND &H20) = 0: WEND       ' WAIT FOR ACK FOR 8032
     CMNDECHO = INP(IOPORTA%)           ' READ ECHO FROM 8032
END SUB

SUB DAC0OUT (V) STATIC

     A = INT(V / 256)
     B = V AND &HFF
     OUT IOPORTB%, DAC0LOADD%
     OUT IOPORTA%, B
     C = A
     OUT IOPORTB%, DAC0HIADD%
     OUT IOPORTA%, A

END SUB

SUB DAC1OUT (V) STATIC
' Ooutput a count to offset D/A converter number # in counts.
' 0 count=-5V, and 4095 count=+5V.

     A = INT(V / 256)
     B = V AND &HFF
     OUT IOPORTB%, DAC1LOADD%
     OUT IOPORTA%, B
     C = A
     OUT IOPORTB%, DAC1HIADD%
     OUT IOPORTA%, A
END SUB

SUB DELAY (A)
  FOR I = 1 TO A: NEXT I
END SUB

SUB DSPTEST
  CALL LATCHOUT(CPURESET%, SET.BIT%)
  CALL LATCHOUT(CPURESET%, CLEAR.BIT%)
  CALL DELAY((10000))
  CALL LATCHOUT(CPURESET%, SET.BIT%)
END SUB

SUB GAIN (GAINMD, GAINTD) STATIC
  DIM ADAVG(5)
  CALL ADMUX((0))                       ' SET MUX
  CALL LATCHOUT(ZEROCAL%, SET.BIT%)     ' SET RELAY TO ZEROCAL POS
  CALL DAC0OUT((0))                     ' SET DAC TO -5V OUT
  CALL DAC1OUT((0))
  CALL DELAY((100))                    ' WAIT FOR 10MS TO SETTLE
  CALL AVGAD(ADAVG(), (100))            ' GET 100 READINGS
  LOWMD = ADAVG(2)
  LOWTD = ADAVG(4)
  CALL DAC0OUT((4095))                  ' SET DAC'S TO +5V OUT
  CALL DAC1OUT((4095))
  CALL DELAY((100))
  CALL AVGAD(ADAVG(), (100))
  HIMD = ADAVG(2)
  HITD = ADAVG(4)
  GAINMD = (HIMD - LOWMD) * .244141
  GAINTD = (HITD - LOWTD) * .244141
END SUB

SUB INTERFACEBUFF (RESULT) STATIC
' Read a number from the interface buffers after a command is issued
     OUT IOPORTB%, IOREAD%
     WHILE (INP(IOPORTC%) AND &H20) = 0: WEND
     RESULT = INP(IOPORTA%)
END SUB

SUB INTTEST (D) STATIC
  CALL LATCHOUT(RUNNING%, SET.BIT%)
  CALL DELAY(D)
  CALL LATCHOUT(RUNNING%, CLEAR.BIT%)
  CALL COMMAND((5), A)
END SUB

SUB iotest
  DO WHILE 1
     OUT IOPORTB%, DAC0LOADD%
     OUT IOPORTA%, B
  LOOP
END SUB

SUB LATCHOUT (BITVAL%, SET.CLR%) STATIC
SHARED INTRFCCNTRL%
'This sub sets or clear the specified bitvalue in the interface control
'latch. The BITVAL% must be the bit value ie. 1,2,4,,8,16,32,64,128 corres-
'ponding to D0 - D7 of the latch.
  IF SET.CLR% = 0 THEN
     INTRFCCNTRL% = INTRFCCNTRL% AND NOT BITVAL%
  ELSE
     INTRFCCNTRL% = INTRFCCNTRL% OR BITVAL%
  END IF
  OUT IOPORTB%, INTRFCLATCH%
  OUT IOPORTA%, INTRFCCNTRL%
END SUB

SUB LEDTEST
  FOR I = 1 TO 10
   CALL LATCHOUT(READY%, SET.BIT%)
   CALL DELAY((1000))
   CALL LATCHOUT(READY%, CLEAR.BIT%)
   CALL DELAY((1000))
  NEXT I
  FOR I = 1 TO 10
   CALL LATCHOUT(MARK%, SET.BIT%)
   CALL DELAY((1000))
   CALL LATCHOUT(MARK%, CLEAR.BIT%)
   CALL DELAY((1000))
  NEXT I
  FOR I = 1 TO 10
   CALL LATCHOUT(RUNNING%, SET.BIT%)
   CALL DELAY((1000))
   CALL LATCHOUT(RUNNING%, CLEAR.BIT%)
   CALL DELAY((1000))
  NEXT I

END SUB

SUB LINEARITY (CHANNEL%) STATIC
  SHARED ADBUFF()
  DIM ADAVG(5)
  SCREEN 9
  VIEW (10, 330)-(600, 280), , 1
  CLS
  MAX = 0
  POINTS = 4095
  CALL DAC0OUT((0)): CALL DAC1OUT((0))
  CALL DELAY((10000)): CALL AVGAD(ADAVG(), (100))
  CHN1.LOW = ADAVG(1): CHN2.LOW = ADAVG(2)
  CALL DAC0OUT((POINTS)): CALL DAC1OUT((POINTS))
  CALL DELAY((10000)): CALL AVGAD(ADAVG(), (100))
  CHN1.HI = ADAVG(1): CHN2.HI = ADAVG(2)
  CHN1.SLOPE = (CHN1.HI - CHN1.LOW) / POINTS
  CHN2.SLOPE = (CHN2.HI - CHN2.LOW) / POINTS
  CHN1.INTCPT = CHN1.LOW
  CHN2.INTCPT = CHN2.LOW
  P = 1
  FOR V = 0 TO POINTS
    CALL DAC0OUT(V): CALL DAC1OUT(V): CALL DELAY((10))
    CALL AVGAD(ADAVG(), (10))
    Y1 = CHN1.SLOPE * V + CHN1.INTCPT
    DELTA1 = Y1 - ADAVG(1)
    IF ABS(DELTA1) > 5 THEN
      LOCATE 19, 1: PRINT "CHN1.HI="; CHN1.HI; "CHN1.LOW="; CHN1.LOW
      LOCATE 20, 1: PRINT "CHN1.SLOPE="; CHN1.SLOPE; "CHN1.INTCPT="; CHN1.INTCPT
      LOCATE 21, 1: PRINT "Y1="; Y1
      LOCATE 22, 1: PRINT "D/A VOLT="; V / 4095 * 10 - 5; "A/D VOLT="; ADAVG(1) / 2048 * 10
      LOCATE 23, 1: PRINT "D/A 2 ERROR @ "; V; "ERROR= "; DELTA1
      V = POINTS        ' Terminate loop
    END IF
    PSET (V / 7, DELTA1 * 5 + 15), 4
    Y2 = CHN2.SLOPE * V + CHN2.INTCPT
    DELTA2 = Y2 - ADAVG(2)
    IF ABS(DELTA2) > 5 THEN
      LOCATE 19, 1: PRINT "CHN2.HI="; CHN2.HI; "CHN2.LOW="; CHN2.LOW
      LOCATE 20, 1: PRINT "CHN2.SLOPE="; CHN2.SLOPE; "CHN2.INTCPT="; CHN2.INTCPT
      LOCATE 21, 1: PRINT "Y="; Y2
      LOCATE 22, 1: PRINT "D/A VOLT="; V / 4095 * 10 - 5; "A/D VOLT="; ADAVG(2) / 2048 * 10
      LOCATE 23, 1: PRINT "D/A 2 ERROR @ "; V; "ERROR= "; DELTA2
      V = POINTS        ' Terminate loop
    END IF
    PSET (V / 7, DELTA2 * 5 + 35), 3
    IF V / 20 > P THEN
       P = P + 1: LOCATE 18, 10: PRINT V
       LOCATE 18, 25: PRINT "DELTA 1=";
       PRINT USING "###.###"; DELTA1;
       PRINT "  DELTA 2=";
       PRINT USING "###.###"; DELTA2
    END IF

    IF INKEY$ <> "" THEN V = POINTS
  NEXT V
END SUB

SUB PORTBTEST
  DIM ADTEMP(5)
  OUT CONTROL%, IOMODES%
  OUT IOBORTB%, ABORT%
  FOR J = 1 TO 10000
    OUT IOPORTB%, ADTRIG%
    WHILE (INP(IOPORTC%) AND &H20) = 0: WEND
    A = INP(IOPORTA%)
    WHILE (INP(IOPORTC%) AND &H20) = 0: WEND
    B = INP(IOPORTA%)
      OUT IOPORTB%, ADNEXT%
      WHILE (INP(IOPORTC%) AND &H20) = 0: WEND
      A = INP(IOPORTA%)
      WHILE (INP(IOPORTC%) AND &H20) = 0: WEND
      B = INP(IOPORTA%)
      OUT IOPORTB%, ADNEXT%
      WHILE (INP(IOPORTC%) AND &H20) = 0: WEND
      A = INP(IOPORTA%)
      WHILE (INP(IOPORTC%) AND &H20) = 0: WEND
      B = INP(IOPORTA%)
      OUT IOPORTB%, ADNEXT%
      WHILE (INP(IOPORTC%) AND &H20) = 0: WEND
      A = INP(IOPORTA%)
      WHILE (INP(IOPORTC%) AND &H20) = 0: WEND
      B = INP(IOPORTA%)
      OUT IOPORTB%, ADNEXT%
      WHILE (INP(IOPORTC%) AND &H20) = 0: WEND
      A = INP(IOPORTA%)
      WHILE (INP(IOPORTC%) AND &H20) = 0: WEND
      B = INP(IOPORTA%)
  NEXT J
  PRINT "*"
END SUB

SUB SCREEN.SETUP
CLS
LOCATE 1, 1: PRINT " 1) +10V REF ADJUST"
LOCATE 2, 1: PRINT " 2) TC F.S. ADJUST"
LOCATE 3, 1: PRINT " 3) DISP. SEG. TEST"
LOCATE 4, 1: PRINT " 4) LED BLINK TEST"
LOCATE 5, 1: PRINT " 5) COMMAND TEST"
LOCATE 6, 1: PRINT " 6) BATTERY TEST"
LOCATE 7, 1: PRINT " 7) RS232 TEST"
LOCATE 8, 1: PRINT " 8) A/D CLOCK TEST"
LOCATE 9, 1: PRINT " 9) TC A/D CONV TEST"
LOCATE 10, 1: PRINT "10) X & Y STRAIN ZERO ADJ"
LOCATE 1, 40: PRINT "11) X & Y GAIN ADJUST"
LOCATE 2, 40: PRINT "12) TC ZERO/GAIN CAL"
LOCATE 3, 40: PRINT "13) D/A-0 SCOPE SWEEP"
LOCATE 4, 40: PRINT "14) D/A-1 SCOPE SWEEP"
LOCATE 5, 40: PRINT "15) A/D -> D/A LIN TEST"
LOCATE 6, 40: PRINT "16) V-EXC ADJ & TEST"
LOCATE 7, 40: PRINT "17) A/D ZERO TEST"
LOCATE 8, 40: PRINT "18) A/D F.S. TESET"
LOCATE 9, 40: PRINT "19) STRAIN,POS A/D TEST"
LOCATE 10, 40: PRINT "20) BRIDGE ZERO TEST"
LOCATE 11, 40: PRINT "21) TEMPERATURE DUMP TEST"
LOCATE 12, 40: PRINT "22) QUIT"

END SUB

SUB sinda0 STATIC
  OUT CONTROL%, IOMODES%
  OUT IOBORTB%, ABORT%
 DO
    FOR I = 0 TO 6.28 STEP .003
      V = INT(2047 + 2047 * SIN(I))
      CALL DAC0OUT(V)
    NEXT I
  LOOP WHILE INKEY$ = ""
END SUB

SUB TEMPDUMP (MODE, DELAY.SEC, MAX.DUMP) STATIC
  ' To transfer temperature data from interface module to IBM
 END.TIME! = TIMER + DELAY.SEC
  IF MODE = 0 THEN
    PRINT "RUNNING TRIGGERS START OF TEMPERATURE DATA STORAGE"
    PRINT "SETTING RUNNING BIT"
    CALL LATCHOUT(RUNNING%, SET.BIT%)             ' START TEMPERATURE STORE
    DO WHILE TIMER < END.TIME!: LOOP
    PRINT "CLEARING RUNNING BIT"
    CALL LATCHOUT(RUNNING%, CLEAR.BIT%)
'    A = INP(IOPORTA%)
  ELSE
    PRINT "CAMMAND 4 STARTS TEMPERATURE DATA STORAGE"
    CALL COMMAND((4), A)                        ' START TEMP STORE
    DO WHILE TIMER < END.TIME!: LOOP
  END IF
  PRINT "COMMAND 5 TO STOP TEMPERATURE STORING"
  CALL COMMAND((5), A)                          ' STOP TEMPERATURE STORING
  CALL COMMAND((6), MSB)                        ' SEND MSB COUNT
  CALL COMMAND((7), LSB)                        ' SEND LSB COUNT
  TEMP.SET = MSB * 256 + LSB
  PRINT "NO OF TEMPERATURE SETS="; TEMP.SET
  IF TEMP.SET > MAX.DUMP THEN TEMP.SET = MAX.DUMP
  CALL COMMAND((1), MSBTMP): CALL COMMAND((2), LSBTMP)
  PRINT MSBTMP * 256 + LSBTMP,
  CALL COMMAND((2), MSBTMP): CALL COMMAND((2), LSBTMP)
  PRINT MSBTMP * 256 + LSBTMP,
  CALL COMMAND((2), MSBTMP): CALL COMMAND((2), LSBTMP)
  PRINT MSBTMP * 256 + LSBTMP,
  CALL COMMAND((2), MSBTMP): CALL COMMAND((2), LSBTMP)
  PRINT MSBTMP * 256 + LSBTMP
  FOR I = 1 TO TEMP.SET - 1
    FOR J = 1 TO 4
      CALL COMMAND((2), MSBTMP): CALL COMMAND((2), LSBTMP)
      PRINT MSBTMP * 256 + LSBTMP,
    NEXT J
    PRINT
  NEXT I
END SUB

